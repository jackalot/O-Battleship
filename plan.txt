Focus: change the function that causes the board.js to recieve an attack:
* player.js
+ inside player.js, a function called callBoardRecieveAttack() {
  + parameters { coordinates }
  + call ourBoard.recieveAttack() with a stored reference to it;
  + call swapTurn();
  + return the result of the attack
}
+ in sendAttack () {
 - remove the stored result of attackingPlayer's board's recieveAttack function
 + instead, store the result of attackingPlayer's callBoardRecieveAttack() function
 - remove the function call that calls attackingPlayer's swapTurn function
 + return the result of callBoardRecieveAttack()
}

* attackDomManager.js 
- delete the line defendingPlayer.ourBoard.recieveAttack 
+ if the defendingPlayer is player1
{
  + player1 will then call sendAttack with the arguments(player2, coordinates)
}
if the defendingPlayer is player2
{
 + player2  will then call sendAttack with the arguments(player1, coordinates)
}
psuedo code:
// player.js \\ 
function callBoardRecieveAttack(coordinates) {
 const result = ourBoard.recieveAttack(coordinates);
 swapTurn();
 return result;
}
// attackDomManager \\

notes:
notes about playerTurn, the variable
at the end of swapVisibility, despite the swapTurn function calls, currently, player1 remains as turn 0
player 2 remains as turn 1 when after player1 attacks, the turn is supposed to swap, so this means
possibly rewriting the player functions so that they both swap AND recieveAttacks. 